module LFSR4bit #(
	 parameter [3:0] tap_vector = 4'b1001 //polynomial tap = x^4 + x + 1
	) (
    input  wire clk,         // clock
    input  wire rst_n,       // active-low reset
    output reg [3:0] lfsr,   // LFSR state
    output wire [3:0] random_num,
    output wire output_bit
);

    reg [25:0] clk_div;

    // Slow clock tick for demo (1 Hz)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            clk_div <= 26'd0;
        else if (clk_div == 26'd49_999_999)
            clk_div <= 26'd0;
        else
            clk_div <= clk_div + 1'b1;
    end
    wire tick = (clk_div == 26'd49_999_999);
	
    assign random_num = lfsr;
    assign output_bit = lfsr[0];
	 wire [3:0] q_vector = {tap_vector[3] & lfsr[0],tap_vector[2] & lfsr[0],tap_vector[1] & lfsr[0],tap_vector[0] & lfsr[0]};
    // Galois LFSR logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            lfsr <= 4'b1111; // initial value
        else 
		  //if (tick) 
		  begin
                // LSB = 1, apply feedback to specific taps
            lfsr[3] <= q_vector[3];
				lfsr[2] <= q_vector[2]^lfsr[3];
				lfsr[1] <= q_vector[1]^lfsr[2];
				lfsr[0] <= q_vector[0]^lfsr[1];
            
        end
    end

endmodule
